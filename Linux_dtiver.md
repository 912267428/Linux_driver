# Linux驱动开发与裸机开发的区别

## 逻辑开发

底层，跟寄存器打交道，有些MCU提供了库。

## Linux驱动开发的思维

1. Linux下驱动开发直接操作寄存器不现实。
2. 根据Linux下的各种驱动框架进行开发。一定要满足框架，也就是Linux下各种驱动框架的掌握。
3. 驱动最终表现就是/dev/xxx文件。打开、关闭、读写、。。。
4. 现在新的内核支持设备树，这个一个.dts文件，此文件 描述了板子的设备信息。

## Linux驱动分类

1. 字符设备驱动。
2. 块设备驱动，存储
3. 网络设备驱动

一个设备不说是一定只属于某一个类型。比如USB WIFI,SDIO WIFI，属于网络设备驱动，因为他又有USB和SDIO，因此也属于字符设备驱动。

# Linux驱动开发

## 字符设备驱动开发

以一个虚拟的设备为例，学习如何进行字符设备驱动开发，以及如何编写测试 APP 来测试驱动工作是否正常。

### 字符设备驱动简介

字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。常见的点灯、按键、IIC、SPI， LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。

### Linux 应用程序对驱动程序的调用流程

在 Linux 中一切皆为文件，驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应用程序通过对这个名为“/dev/xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实 现对硬件的操作。应用程序可以通过各种API函数来操作这个驱动文件以完成打开、关闭以及读写等任务。

应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间。 当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开/dev/led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空 间“陷入”（软件中断）到内核空间，这样才能实现对底层驱动的操作。open、close、write 和 read 等这些函数是由 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分。

![image-20231005162342014](image\19.png)

关于 C 库以及如何通过系统调用“陷入”到内核空间这个我们不用去管，我们重点关注的是应用程序和具体的驱动，应用程序使用到的函数在具体驱动程序中都有与之对应的函数， 比如应用程序中调用了 open 这个函数，那么在驱动程序中也得有一个名为 open 的函数。
每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 **include/linux/fs.h**中有个叫做 **file_operations** 的结构体，此结构体就是Linux内核驱动操作函数集合。

### 字符设备驱动开发步骤

在 Linux 驱动开发中需要按照其规定的框架来编写驱动，所以说学 Linux 驱动开发重点是学习其驱动框架。

#### 1、驱动模块的加载和卸载

Linux 驱动有两种运行方式：

1. 将驱动编译进 Linux 内核中，这样当 Linux 内核启 动的时候就会自动运行驱动程序
2. 将驱动编译成模块(Linux 下模块扩展名为.ko)，在 Linux 内核启动以后使用“insmod”命令加载驱动模块

在调试驱动的时候一般都选择将其编译 为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。而且在调试的时候只需要加载或者卸载驱动模块即可，不需要重启整个系统。

模块有加载和卸载两种操作，我们在编写驱动的时候需要注册这两种操作函数，模块的加载和 卸载注册函数如下：

```
module_init(xxx_init); //注册模块加载函数
module_exit(xxx_exit); //注册模块卸载函数
```

module_init 函数用来向 Linux 内核注册一个模块加载函数，参数 xxx_init 就是需要注册的具体函数，当使用“insmod”命令加载驱动的时候，xxx_init 这个函数就会被调用。module_exit() 函数用来向 Linux 内核注册一个模块卸载函数，参数 xxx_exit 就是需要注册的具体函数，当使 用“rmmod”命令卸载具体驱动的时候 xxx_exit 函数就会被调用。

驱动编译完成以后扩展名为.ko，有两种命令可以加载驱动模块：insmod和modprobe

这两个命令的区别在于：insmod不能解决模块之间的依赖关系，必须逐个加载模块。
modprobe命令可以解决问题，其会分析模块之间的依赖关系，然后会将所有的依赖模块都加载到内核中

modprobe 命令默认会去 /lib/modules/目录中查找模块，比如这里使用的 Linux kernel 的版本号为 4.1.15， 因此 modprobe 命令默认会到/lib/modules/4.1.15 这个目录中查找相应的驱动模块，一般自己制作的根文件系统中是不会有这个目录的，所以需要自己手动创建。

使用 modprobe 命令可以卸载掉驱动模块所依赖的其他模块，前提是这些依赖模块已经没 有被其他模块所使用，否则就不能使用 modprobe 来卸载驱动模块。所以对于模块的卸载，还是推荐使用 rmmod 命令。

#### 2、字符设备注册于注销

对于字符设备驱动而言，当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模 块的时候也需要注销掉字符设备。字符设备的注册和注销函数原型如下所示:

```c
static inline int register_chrdev(unsigned int major, const char *name,
									const struct file_operations *fops)
static inline void unregister_chrdev(unsigned int major, const char *name)
```

register_chrdev 函数用于注册字符设备，此函数一共有三个参数，这三个参数的含义如下：

- major：主设备号，Linux 下每个设备都有一个设备号，设备号分为主设备号和次设备号两部分
- name：设备名字，指向一串字符串。
- fops：结构体 file_operations 类型指针，指向设备的操作函数集合变量。

unregister_chrdev 函数用户注销字符设备，此函数有两个参数，这两个参数含义如下：

- major：要注销的设备对应的主设备号。
- name：要注销的设备对应的设备名。

一般字符设备的注册在驱动模块的入口函数 xxx_init 中进行，字符设备的注销在驱动模块 的出口函数 xxx_exit 中进行。

#### 3、实现设备的具体操作函数

file_operations 结构体就是设备的具体操作函数。要使用该结构体中的函数需要对其进行初始化，也就是初始化其中的open、 release、read 和 write 等具体的设备操作函数。

假设对 chrtest 这个设备有如下两个要求：

1. **能够对 chrtest 进行打开和关闭操作**

   设备打开和关闭是最基本的要求，几乎所有的设备都得提供打开和关闭的功能。因此我们需要实现 file_operations 中的 open 和 release 这两个函数。

2. **对 chrtest 进行读写操作**

   假设 chrtest 这个设备控制着一段缓冲区(内存)，应用程序需要通过 read 和 write 这两个函数对 chrtest 的缓冲区进行读写操作。所以需要实现 file_operations 中的 read 和 write 这两个函数。

#### 4、添加 LICENSE 和作者信息

最后我们需要在驱动中加入 LICENSE 信息和作者信息，其中 LICENSE 是必须添加的，否则的话编译的时候会报错，作者信息可以添加也可以不添加。LICENSE 和作者信息的添加使用 如下两个函数：

```
MODULE_LICENSE() //添加模块 LICENSE 信息
MODULE_AUTHOR() //添加模块作者信息
```

### Linux设备号

#### 设备号的组成

为了方便管理，Linux 中每个设备都有一个设备号，设备号由主设备号和次设备号两部分组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。

Linux 提供了 一个名为 dev_t 的数据类型表示设备号，dev_t 定义在文件 include/linux/types.h 里面，定义如下：

```
typedef __u32 __kernel_dev_t;
......
typedef __kernel_dev_t dev_t;
```

dev_t 是__u32 类型的，而__u32 定义在文件 include/uapi/asm-generic/int-ll64.h 里面：

typedef unsigned int __u32;

dev_t 其实就是 unsigned int 类型，是一个 32 位的数据类型。这 32 位的数据构成了主设备号和次设备号两部分，其中高 12 位为主设备号，低 20 位为次设备号。因此 Linux 系统中主设备号范围为 0~4095，所以在选择主设备号的时候一定不要超过这个范围。在文件 include/linux/kdev_t.h 中提供了几个关于设备号的操作函数(本质是宏)，如下所示：

```
#define MINORBITS 20
#define MINORMASK ((1U << MINORBITS) - 1)

#define MAJOR(dev) ((unsigned int) ((dev) >> MINORBITS))
#define MINOR(dev) ((unsigned int) ((dev) & MINORMASK))
#define MKDEV(ma,mi) (((ma) << MINORBITS) | (mi))
```

#### 设备号的分配

##### 1、静态分配设备号

本小节讲的设备号分配主要是主设备号的分配。前面讲解字符设备驱动的时候说过了，注 册字符设备的时候需要给设备指定一个设备号，这个设备号可以是驱动开发者静态的指定一个 设备号，比如选择 200 这个主设备号。有一些常用的设备号已经被 Linux 内核开发者给分配掉 了，具体分配的内容可以查看文档 Documentation/devices.txt。并不是说内核开发者已经分配掉 的主设备号我们就不能用了，具体能不能用还得看我们的硬件平台运行过程中有没有使用这个 主设备号，使用“cat /proc/devices”命令即可查看当前系统中所有已经使用了的设备号。

##### 2、动态分配设备号

静态分配设备号需要我们检查当前系统中所有被使用了的设备号，然后挑选一个没有使用 的。而且静态分配设备号很容易带来冲突问题，Linux 社区推荐使用动态分配设备号，在注册字 符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突。 卸载驱动的时候释放掉这个设备号即可，设备号的申请函数如下：

```
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)
```

函数 alloc_chrdev_region 用于申请设备号，此函数有 4 个参数：

1. dev：保存申请到的设备号。
2. baseminor：次设备号起始地址，alloc_chrdev_region 可以申请一段连续的多个设备号，这 些设备号的主设备号一样，但是次设备号不同，次设备号以 baseminor 为起始地址地址开始递 增。一般 baseminor 为 0，也就是说次设备号从 0 开始。
3. count：要申请的设备号数量。
4. name：设备名字。

注销字符设备之后要释放掉设备号，设备号释放函数如下：

```
void unregister_chrdev_region(dev_t from, unsigned count)
```

两个参数：

1. from：要释放的设备号。
2. count：表示从 from 开始，要释放的设备号数量。

### chrdevbase 字符设备驱动开发实验

以 chrdevbase 这个虚拟设备为例，完整的编写一个字符设备驱动模块。chrdevbase 不是实际存在的一个设备，是为了方便讲解字符设备的开发而引入的一个虚拟设备。chrdevbase 设备有两个缓冲区，一个为读缓冲区，一个为写缓冲区，这两个缓冲区的大小都为 100 字节。在应用程序中可以向 chrdevbase 设备的写缓冲区中写入数据，从读缓冲区中读取数据。chrdevbase 这个虚拟设备的功能很简单，但是它包含了字符设备的最基本功能。

